% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nonHomogeneousPoissonProcess.R
\name{nhpp}
\alias{nhpp}
\alias{nhppLoglik}
\title{Non-homogeneous Poisson Process functions}
\usage{
nhppLoglik(
  pars,
  data,
  u,
  b = 1,
  nb = 365,
  individual = FALSE,
  tol = 1e-04,
  epsilon = 1e-15
)
}
\arguments{
\item{pars}{A numeric parameter vector of length 3 containing the respective
values of the GEV location \eqn{\mu}, scale \eqn{\sigma} and shape
\eqn{\xi} parameters of a Generalised Extreme Value (GEV) approximation to
the distribution of \eqn{b}-year block maxima. The value of \eqn{b} is
set using the argument \code{b}.}

\item{data}{A numeric vector of observations.}

\item{u}{A numeric scalar. The extreme value threshold applied to the data.}

\item{b}{A numeric scalar. The value of \eqn{b}.}

\item{nb}{A numeric scalar. The mean number of observations (including
missing values) per \eqn{b}-year block.}

\item{individual}{A logical scalar. Relevant to \code{nhppLoglik} and
\code{nhppScore}. If \code{individual = FALSE} then only the sum of
contributions from all observations in \code{maxima} is calculated.  If
\code{individual = TRUE} then individual contributions from each
observation in \code{maxima} are calculated.}

\item{tol}{A positive numeric scalar.  Tolerance used to determine whether
to perform a calculation directly or via a series expansion approximation.
See \strong{Details}.}

\item{epsilon}{The desired error margin when an approximation is used.}
}
\value{
\strong{Log-likelihood} (\code{gevLoglik}). If
  \code{individual = FALSE} the value of the log-likelihood. If
  \code{individual = TRUE} a vector of length \code{length{maxima}}
  containing the contributions to the log-likelihood from each of the
  observations.

\strong{Score} (\code{gevScore}).  If \code{individual = FALSE} the value
 of the score, a vector of length 2 containing the derivative of the
 log-likelihood evaluated at the input parameter values.
 If \code{individual = TRUE} the values of the contributions to the score
 from each of the observations, a
  \code{length(maxima)}\eqn{ \times 2}{ x 2} matrix.
  The columns are named \code{sigma[u]} and \code{xi}.

\strong{Observed information} (\code{gevInfo}).  The observed information: a
  \eqn{2 \times 2}{2 x 2} matrix with row and column names
  \code{c(sigma[u], xi)}.
}
\description{
Calculate the log-likelihood function, score and observed information for
a random sample from a non-homogeneous Poisson Process (NHPP) model for
threshold exceedances, including cases where the shape parameter is very
close to zero.
}
\details{
\strong{Log-likelihood} (\code{nhppLoglik}). The two problematic
  terms of the log-likelihood both involve the function
  \ifelse{html}{log(1+z)/z}{\eqn{\log(1+z)/z}}. In one term
  \ifelse{html}{z=\eqn{\xi}\eqn{(u - \mu)} / \eqn{\sigma}}{
  \eqn{z} = \eqn{\xi}\eqn{(u - \mu)} / \eqn{\sigma}},
  in the other
  \ifelse{html}{z=\eqn{\xi}\eqn{(y - \mu)} / \eqn{\sigma}}{
  \eqn{z} = \eqn{\xi}\eqn{(y - \mu)} / \eqn{\sigma}},
  where \eqn{u} is the threshold and \eqn{y} is a observation that exceeds
  the threshold. In the first of these terms this function is exponentiated,
  in the other it is not.
  If \eqn{|z| \geq}{|z| >=} \code{tol} then this is calculated directly,
  using \code{log1p(z)/z}.
  If \eqn{|z| <} \code{tol} then we use \code{\link[sumR]{infiniteSum}}
  to approximate the series \ifelse{html}{log(1+z)/z}{\eqn{\log(1+z)/z}}
  \ifelse{html}{= 1 - z/2 + z\out{<sup>2</sup>}/3 - z\out{<sup>3</sup>}/4 +
  ...}{\eqn{= 1 - z/2 + z^2/3 - z^3/4 + \cdots}}. Before the call to
  \code{\link[sumR]{infiniteSum}} the input value of \code{epsilon}
  is adjusted to achieve the desired error margin for the approximation of
  the log-likelihood, taking into account the error of approximation from
  both terms. If \code{z = 0} then
  \ifelse{html}{log(1+z)/z = 1}{\eqn{\log(1+z)/z} = 1}.
}
\examples{
### Simulate some data

set.seed(17042022)
y <- rGenExtremeValue(365, 0, 1, 0)
u <- quantile(y, probs = 0.9)

### Log-likelihood

# Approximation using sumR::infinitesum()
nhppLoglik(pars = c(0, 1, 1e-8), data = y, u = u, individual = TRUE)
nhppLoglik(pars = c(0, 1, -1e-8), data = y, u = u, individual = TRUE)
nhppLoglik(pars = c(0, 1, 0), data = y, u = u, individual = TRUE)

# Direct calculation, involving (1 / xi) * log1p(xi * (y - mu) / sigma)
# and (1 / xi) * log1p(xi * (u - mu) / sigma)
# Mostly fine, but breaks down eventually
nhppLoglikDirect(pars = c(0, 1, 1e-323), data = y, u = u)
nhppLoglikDirect(pars = c(0, 1, -1e-323), data = y, u = u)
}
