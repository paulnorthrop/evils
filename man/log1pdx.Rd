% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/log1pdx.R
\name{log1pdx}
\alias{log1pdx}
\title{Accurate \code{log(1+x)/x} computation}
\usage{
log1pdx(
  x,
  tol_logcf = 1e-14,
  eps2 = 0.01,
  minL1 = -0.79149064,
  trace.lcf = FALSE,
  logCF = if (is.numeric(x)) DPQ::logcf else DPQ::logcfR.
)
}
\arguments{
\item{epsilon}{The desired error margin when an approximation is used.}
}
\value{
Returns
}
\description{
Compute \eqn{\log(1+x)/x} accurately also for small \eqn{x}, that is,
\eqn{|x| \ll 1}{|x| << 1}
}
\details{
Add details
\itemize{
\item Do not need to treat \eqn{\xi = 0} as a special case.
\item The expansion should not be in \eqn{\xi} but in something else.
\item I can generalise the existing R function for a series approximation with
an arbitrary numebr of terms.
\item Create a C++ version.
}
}
\examples{
# In the limit as x tends to 0 log(1+x)/x = 1
log1pdx(0)

#
x <- seq(from = -1, to = 4, by = 0.01)
y1 <- log1pdx(x)
y2 <- log1p(x) / x
y3 <- log(1 + x) / x
y <- cbind(y1, y2, y3)
matplot(x, y, type = "l")

#
ep <- 1e-8
x <- seq(from = -ep, to = ep, len = 10001)
y1 <- log1pdx(x)
y2 <- log1p(x) / x
y3 <- log(1 + x) / x # y3 is known to behave poorly near 0
y <- cbind(y1, y2)
matplot(x, y, type = "l", lty = 1, col = c("black", "red", "green"))
}
